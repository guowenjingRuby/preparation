1.为什么要用封装？
Dog dog=new Dog();
#Dog类里面name不是私有的，可以随意访问。----->有一些非法的输入
dog.name="狗子"  为了防止通过这句话对name进行随意赋值。
    |
将Dog类中name成员变量变成private,变成private之后外界访问不到了，正常的赋值无法进行？
    |
1.构造方法赋值，那如何防止非法输入呢？通过构造方法里面的代码进行控制。
2.set方法赋值，那如何防止非法输入呢？通过set方法里面的代码进行控制。

解决了既能赋正确的值，也能防止非法输入，实现了信息安全，类内部信息隐藏的作用

如果外界想要获取Dog类中的name值？通过get方法获取。

总结：构造方法、set、get方法都是外界访问的窗口，所以是public。
     this关键字。调用本类的成员变量(this.成员变量名)、调用本类的成员方法（this.方法名（））、调用本类的构造方法（this(参数列表)）
     构造方法的作用、自己不写任何构造方法，系统一个无惨无内容的构造方法，当我们自己重载了构造方法，默认提供的就不在起作用。
     构造方法重载：方法名相同，参数列表不同。

为什么要用继承？好处？
狗类中、name、health、love。生成了三对setget方法。9+25行代码
企鹅类中:name/health.love。9+25行代码。------>代码冗余
分析得知：有几个继承代码省了几倍。--->子类复用父类的代码。---->提高了开发的效率。
   |
    super关键字。
    调用父类的构造方法(super(参数列表))
    调用父类的属性(super.name。必须name不是private的)
    调用父类的成员方法(super.方法()。必须方法不是private的)


   成员变量被private/default/protected/public。区别？
       private修饰只能在本类中使用.
       defaul修饰本类、子类、同包类（通过对象去调用的）可以访问,不同包下不能访问。
       protected 修饰本类、子类、同包类（通过对象去调用的）可以访问,不同包下不能访问。
       public  修饰本类、子类、同包类（通过对象去调用的）、不同包类下能访问（通过对象去调用的）。

   如果不通过对象去访问成员变量。
       private是本类使用。 默认、protected、public都只能本类及子类使用。


   成员方法被private/default/protected/public。区别。？
   private修饰只能在本类中使用.
   默认的  本类和子类及同包下（通过对象去调用的）可以使用,不同包下不可以使用（即使通过对象去调用）.
   protected 本类和子类及同包下（通过对象去调用的）可以使用,不同包下不可以使用（即使通过对象去调用）.
   public  修饰本类、子类、同包类（通过对象去调用的）、不同包类下能访问（通过对象去调用的）。

   如果不通过对象去访问：
        private 是本类使用。 默认的、protected、public都只能本类及子类调用。


重写：父类中的方法不能满足子类的需求，子类需要对父类的方法进行改造重写。
    注意事项：子类重写父类方法的访问权限必须大于等于父类方法的权限。
            重写的方法可以通过super关键字调用父类同名方法。调用语法super.方法名（）如super.printInfo()

1.如果子类的构造方法中，没有通过super显示的调用父类的构造方法，也没有通过this显示的调用自身的构造方法。
系统默认调用父类的无参的构造方法。不加和super()效果一样.
代码操作：执行Test类中的代码。输出：执行宠物类的无参构造方法，
2.调用父类的有参的构造方法,执行父类相应的有参的构造方法。
3.如果子类构造方法中通过this显式调用自身的其他构造方法，在this调用的相应构造方法中应用以上两条规则。
4.特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。



注意：this语句和super语句只能出现在构造方法体中的第一句，并且有且只能有一个。
    类方法中不允许出现super和this关键字。类方法：方法前有static关键字的方法。
    实例方法中允许出现super和this共存，也不要求是第一句。

抽象类总结：
抽象类和抽象方法都是通过abstract关键字来修饰的
抽象类不能实例化，抽象类中可以没有，可以有一个或多个抽象方法，甚至可以全部方法都是抽象方法;
有抽象方法的类必须声明为抽象类，子类必须重写所有的抽象方法才能实例化，否者子类还是一个抽象类。

Abstract可以修饰类和方法，，但不能修饰属性和构造方法。不能和private同时修饰一个方法。不能和static同时修饰一个方法。


final总结：
用final修饰的类，不能再被继承；
用final修饰的方法，不能被子类重写；
用final修饰的变量（包括成员变量和局部变量）将变成常量，只能赋值一次。
final和abstract是功能相反的两个关键字，不能同时使用

抽象类中还可以有非抽象方法。
接口：接口中所有的方法必须为抽象方法。

